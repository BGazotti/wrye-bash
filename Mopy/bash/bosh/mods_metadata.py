# -*- coding: utf-8 -*-
#
# GPL License and Copyright Notice ============================================
#  This file is part of Wrye Bash.
#
#  Wrye Bash is free software: you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation, either version 3
#  of the License, or (at your option) any later version.
#
#  Wrye Bash is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with Wrye Bash.  If not, see <https://www.gnu.org/licenses/>.
#
#  Wrye Bash copyright (C) 2005-2009 Wrye, 2010-2021 Wrye Bash Team
#  https://github.com/wrye-bash
#
# =============================================================================
from __future__ import division

import io
from collections import defaultdict

from ._mergeability import is_esl_capable
from .. import balt, bolt, bush, bass, load_order
from ..bolt import dict_sort, structs_cache
from ..brec import ModReader, SubrecordBlob
from ..exception import CancelError
from ..mod_files import ModHeaderReader

_wrld_types = frozenset((b'CELL', b'WRLD'))

# BashTags dir ----------------------------------------------------------------
def get_tags_from_dir(plugin_name):
    """Retrieves a tuple containing a set of added and a set of deleted
    tags from the 'Data/BashTags/PLUGIN_NAME.txt' file, if it is
    present.

    :param plugin_name: The name of the plugin to check the tag file for.
    :return: A tuple containing two sets of added and deleted tags."""
    # Check if the file even exists first
    tag_files_dir = bass.dirs[u'tag_files']
    tag_file = tag_files_dir.join(plugin_name.body + u'.txt')
    if not tag_file.isfile(): return set(), set()
    removed, added = set(), set()
    # BashTags files must be in UTF-8 (or ASCII, obviously)
    with tag_file.open(u'r', encoding=u'utf-8') as ins:
        for tag_line in ins:
            # Strip out comments and skip lines that are empty as a result
            tag_line = tag_line.split(u'#')[0].strip()
            if not tag_line: continue
            for tag_entry in tag_line.split(u','):
                # Guard against things (e.g. typos) like 'TagA,,TagB'
                if not tag_entry: continue
                tag_entry = tag_entry.strip()
                # If it starts with a minus, it's removing a tag
                if tag_entry[0] == u'-':
                    # Guard against a typo like '- C.Water'
                    removed.add(tag_entry[1:].strip())
                else:
                    added.add(tag_entry)
    return added, removed

def save_tags_to_dir(plugin_name, plugin_tag_diff):
    """Compares plugin_tags to plugin_old_tags and saves the diff to
    Data/BashTags/PLUGIN_NAME.txt.

    :param plugin_name: The name of the plugin to modify the tag file for.
    :param plugin_tag_diff: A tuple of two sets, as returned by diff_tags,
        representing a diff of all bash tags currently applied to the
        plugin in question vs. all bash tags applied to the plugin
        by its description and the LOOT masterlist / userlist.."""
    tag_files_dir = bass.dirs[u'tag_files']
    tag_files_dir.makedirs()
    tag_file = tag_files_dir.join(plugin_name.body + u'.txt')
    # Calculate the diff and ignore the minus when sorting the result
    tag_diff_add, tag_diff_del = plugin_tag_diff
    processed_diff = sorted(tag_diff_add | {u'-' + t for t in tag_diff_del},
                            key=lambda t: t[1:] if t[0] == u'-' else t)
    # While BashTags files can be UTF-8, our generated files are only ever
    # going to be ASCII, so write them with that encoding
    with tag_file.open(u'w', encoding=u'ascii') as out:
        # Stick a header in there to indicate that it's machine-generated
        # Also print the version, which could be helpful
        out.write(u'# Generated by Wrye Bash %s\n' % bass.AppVersion)
        out.write(u', '.join(processed_diff) + u'\n')

def diff_tags(plugin_new_tags, plugin_old_tags):
    """Returns two sets, the first containing all added tags and the second all
    removed tags."""
    return plugin_new_tags - plugin_old_tags, plugin_old_tags - plugin_new_tags

#--Plugin Checker -------------------------------------------------------------
_cleaning_wiki_url = (u'[[!https://tes5edit.github.io/docs/7-mod-cleaning-and'
                      u'-error-checking.html|Tome of xEdit]]')

def checkMods(mc_parent, showModList=False, showCRC=False, showVersion=True,
              scan_plugins=True):
    """Checks currently loaded mods for certain errors / warnings.
    mod_checker should be the instance of PluginChecker, to scan."""
    # Setup some commonly used collections of plugin info
    from . import modInfos
    all_present_minfs = [modInfos[x] for x in load_order.cached_lo_tuple()]
    all_active_plugins = set(load_order.cached_active_tuple())
    game_master_name = bush.game.master_file
    vanilla_masters = bush.game.bethDataFiles
    log = bolt.LogFile(io.StringIO())
    # -------------------------------------------------------------------------
    # Check for ESL-capable plugins that aren't ESL-flagged.
    can_esl_flag = modInfos.mergeable if bush.game.check_esl else set()
    # -------------------------------------------------------------------------
    # Check for ESL-flagged plugins that aren't ESL-capable.
    remove_esl_flag = set()
    if bush.game.check_esl:
        for m, modinf in modInfos.iteritems():
            if not modinf.is_esl():
                continue # we check .esl extension and ESL flagged mods
            if not is_esl_capable(modinf, modInfos, reasons=None):
                remove_esl_flag.add(m)
    # -------------------------------------------------------------------------
    # Check for mergeable plugins that aren't merged into a BP.
    can_merge = ((all_active_plugins & modInfos.mergeable)
                 if not bush.game.check_esl else set())
    # Don't bug users to merge NoMerge-tagged plugins
    for mod in tuple(can_merge):
        if u'NoMerge' in modInfos[mod].getBashTags():
            can_merge.discard(mod)
    # -------------------------------------------------------------------------
    # Check for Deactivate-tagged plugins that are active and
    # MustBeActiveIfImported-tagged plugins that are imported, but inactive.
    should_deactivate = []
    should_activate = []
    for p_minf in all_present_minfs:
        p_ci_key = p_minf.ci_key
        p_active = p_ci_key in all_active_plugins
        p_imported = p_ci_key in modInfos.imported
        p_tags = p_minf.getBashTags()
        if u'Deactivate' in p_tags and p_active:
            should_deactivate.append(p_ci_key)
        if u'MustBeActiveIfImported' in p_tags and not p_active and p_imported:
            should_activate.append(p_ci_key)
    # -------------------------------------------------------------------------
    # Check for missing or delinquent masters
    seen_plugins = set()
    p_missing_masters = set()
    p_delinquent_masters = set()
    for p in load_order.cached_active_tuple():
        for p_master in modInfos[p].masterNames:
            if p_master not in all_active_plugins:
                p_missing_masters.add(p)
            if p_master not in seen_plugins:
                p_delinquent_masters.add(p)
        seen_plugins.add(p)
    # -------------------------------------------------------------------------
    # Check for plugins with invalid TES4 version.
    valid_vers = bush.game.Esp.validHeaderVersions
    invalid_tes4_versions = {x: unicode(round(modInfos[x].header.version, 6))
                             for x in all_active_plugins if round(
            modInfos[x].header.version, 6) not in valid_vers}
    # -------------------------------------------------------------------------
    # Check for cleaning information from LOOT.
    cleaning_messages = {}
    scan_for_cleaning = set()
    dirty_msgs = [(m.ci_key, m.getDirtyMessage()) for m in all_present_minfs]
    for x, y in dirty_msgs:
        if y[0]:
            cleaning_messages[x] = y[1]
        elif scan_plugins:
            scan_for_cleaning.add(x)
    # -------------------------------------------------------------------------
    # Scan plugins to collect data for more detailed analysis.
    # Maps plugin names to the collected data for that mod
    all_extracted_data = defaultdict(dict)
    if scan_plugins:
        try:
            # Extract data for all plugins (we'll need the context from all of
            # them, even the game master)
            with balt.Progress(_(u'Checking Plugins...'), u'\n' + u' ' * 60,
                               parent=mc_parent, abort=True) as progress:
                progress.setFull(len(all_present_minfs))
                for i, present_minf in enumerate(all_present_minfs):
                    mod_progress = bolt.SubProgress(progress, i, i + 1)
                    ext_data = ModHeaderReader.extract_mod_data(present_minf,
                                                                mod_progress)
                    all_extracted_data[present_minf.ci_key] = ext_data
        except CancelError:
            pass
    # -------------------------------------------------------------------------
    # Check for deleted records in the plugins.
    all_ref_types = bush.game.Esp.reference_types
    deleted_navmeshes = {}
    deleted_base_recs = {}
    for p_ci_key, ext_data in all_extracted_data.iteritems():
        def discard_fid(_r_fid): pass
        deleted_navms = []
        # If we have a LOOT report for a plugin, we can skip every deleted
        # reference and deleted navmesh
        deleted_navms_append = (discard_fid if p_ci_key in scan_for_cleaning
                                else deleted_navms.append)
        deleted_refrs = []
        deleted_refrs_append = (discard_fid if p_ci_key in scan_for_cleaning
                                else deleted_refrs.append)
        deleted_others = []
        deleted_others_append = deleted_others.append
        for r, d in ext_data.iteritems():
            if p_ci_key == game_master_name:
                # The game master can't have deleted records (deleting a record
                # from the master file that introduced it just removes the
                # record from existence entirely)
                continue
            for r_fid, (r_header, _r_eid) in d.iteritems():
                # Check the deleted flag - unpacking flags is too expensive
                if r_header.flags1 & 0x00000020:
                    w_rec_type = r_header.recType
                    if w_rec_type == b'NAVM':
                        deleted_navms_append(r_fid)
                    elif w_rec_type in all_ref_types:
                        deleted_refrs_append(r_fid)
                    else:
                        deleted_others_append(r_fid)
        if deleted_refrs:
            num_deleted = len(deleted_refrs)
            if num_deleted == 1: # I hate natural languages :P
                del_msg = _(u'1 deleted reference')
            else:
                del_msg = _(u'%d deleted references') % num_deleted
            cleaning_messages[p_ci_key] = del_msg
        # Deleted navmeshes and base records can't and shouldn't be fixed in
        # vanilla files, so don't show warnings for them
        plugin_is_vanilla = p_ci_key in vanilla_masters
        if deleted_navms and not plugin_is_vanilla:
            num_deleted = len(deleted_navms)
            if num_deleted == 1:
                del_msg = _(u'1 deleted navmesh')
            else:
                del_msg = _(u'%d deleted navmeshes') % num_deleted
            deleted_navmeshes[p_ci_key] = del_msg
        if deleted_others and not plugin_is_vanilla:
            num_deleted = len(deleted_others)
            if num_deleted == 1:
                del_msg = _(u'1 deleted base record')
            else:
                del_msg = _(u'%d deleted base records') % num_deleted
            deleted_base_recs[p_ci_key] = del_msg
    # From here on we have data on all plugin problems, so it's purely a matter
    # of building the log
    def log_plugins(plugin_list):
        for p in sorted(plugin_list):
            log(u'* __%s__' % p)
    def log_plugin_messages(plugin_dict):
        for p, p_msg in dict_sort(plugin_dict):
            log(u'* __%s:__  %s' % (p, p_msg))
    if can_esl_flag:
        log.setHeader(u'=== ' + _(u'ESL Capable'))
        log(_(u'The following plugins could be assigned an ESL flag.'))
        log_plugins(can_esl_flag)
    if remove_esl_flag:
        log.setHeader(u'=== ' + _(u'Incorrect ESL Flag'))
        log(_(u'The following plugins have an ESL flag, but do not qualify. '
              u"Either remove the flag with 'Remove ESL Flag', or "
              u"change the extension to '.esp' if it is '.esl'."))
        log_plugins(remove_esl_flag)
    if can_merge:
        log.setHeader(u'=== ' + _(u'Mergeable'))
        log(_(u'The following plugins are active, but could be merged into '
              u'the Bashed Patch.'))
        log_plugins(can_merge)
    if should_deactivate:
        log.setHeader(u'=== ' + _(u'Deactivate-tagged But Active'))
        log(_(u"The following plugins are tagged with 'Deactivate' and should "
              u'be deactivated and imported into the Bashed Patch.'))
        log_plugins(should_deactivate)
    if should_activate:
        log.setHeader(u'=== '+_(u'MustBeActiveIfImported-tagged But Inactive'))
        log(_(u'The following plugins are tagged with '
              u"'MustBeActiveIfImported' and should be activated if they are "
              u'also imported into the Bashed Patch. They are currently '
              u'imported, but not active.'))
        log_plugins(should_activate)
    if p_missing_masters:
        log.setHeader(_(u'Missing Masters'))
        log(_(u'The following plugins have missing masters and are active. '
              u'This will cause a CTD at the main menu and must be '
              u'corrected.'))
        log_plugins(p_missing_masters)
    if p_delinquent_masters:
        log.setHeader(_(u'Delinquent Masters'))
        log(_(u'The following plugins have delinquent masters, i.e. masters '
              u'that are set to load after their dependent plugins. The game '
              u'will try to force them to load before the dependent plugins, '
              u'which can lead to unpredictable or undefined behavior and '
              u'must be corrected.'))
        log_plugins(p_delinquent_masters)
    if invalid_tes4_versions:
        # Always an ASCII byte string, so this is fine
        p_header_sig = bush.game.Esp.plugin_header_sig.decode(u'ascii')
        ver_list = u', '.join(
            sorted(unicode(v) for v in bush.game.Esp.validHeaderVersions))
        log.setHeader(u'=== ' + _(u'Invalid %s versions') % p_header_sig)
        log(_(u"The following plugins have a %s version that isn't "
              u'recognized as one of the standard versions (%s). This is '
              u'undefined behavior. It can possibly be corrected by resaving '
              u'the plugins in the %s.') % (p_header_sig, ver_list,
                                            bush.game.Ck.long_name))
        log_plugin_messages(invalid_tes4_versions)
    if cleaning_messages:
        log.setHeader(u'=== ' + _(u'Cleaning With %s Needed') %
                      bush.game.Xe.full_name)
        log(_(u'The following plugins have deleted references or other issues '
              u'that can and should be fixed with %(xedit_name)s. Visit the '
              u'%(cleaning_wiki_url)s for more information.') % {
            u'cleaning_wiki_url': _cleaning_wiki_url,
            u'xedit_name': bush.game.Xe.full_name})
        log_plugin_messages(cleaning_messages)
    if deleted_navmeshes:
        log.setHeader(u'=== ' + _(u'Deleted Navmeshes'))
        log(_(u'The following plugins have deleted navmeshes. They will cause '
              u'a CTD if another plugin references the deleted navmesh or a '
              u'nearby navmesh. They can only be fixed manually, which should '
              u'usually be done by the mod author. Failing that, the safest '
              u'course of action is to uninstall the plugin.'))
        log_plugin_messages(deleted_navmeshes)
    if deleted_base_recs:
        log.setHeader(u'=== ' + _(u'Deleted Base Records'))
        log(_(u'The following plugins have deleted base records. If another '
              u'plugin references the deleted record, the resulting behavior '
              u'is undefined. It may CTD, fail to delete the record or do any '
              u'number of other things. They can only be fixed manually, '
              u'which should usually be done by the mod author. Failing that, '
              u'the safest course of action is to uninstall the plugin.'))
        log_plugin_messages(deleted_base_recs)
    # If we haven't logged anything (remember, the header is a separate
    # variable) then let the user know they have no problems.
    temp_log = log.out.getvalue()
    if not temp_log:
        log.setHeader(u'=== ' + _(u'No Problems Found'))
        log(_(u'Wrye Bash did not find any problems with your installed '
              u'plugins. Congratulations!'))
    # We already logged missing or delinquent masters up above, so don't
    # duplicate that info in the mod list
    if showModList:
        log(u'\n' + modInfos.getModList(showCRC, showVersion, wtxt=True,
                                        log_problems=False).strip())
    # Finally, add the header at the start of the log
    log_header = u'= ' + _(u'Check Plugins') + u'\n'
    log_header += _(u'This is a report of any problems Wrye Bash was able to '
                    u'identify in your currently installed plugins.')
    log_header += u'\n\n'
    return log_header + log.out.getvalue()

#------------------------------------------------------------------------------
class NvidiaFogFixer(object):
    """Fixes cells to avoid nvidia fog problem."""
    def __init__(self,modInfo):
        self.modInfo = modInfo
        self.fixedCells = set()

    def fix_fog(self, progress, __unpacker=structs_cache[u'=12s2f2l2f'].unpack,
                __wrld_types=_wrld_types,
                __packer=structs_cache[u'12s2f2l2f'].pack):
        """Duplicates file, then walks through and edits file as necessary."""
        progress.setFull(self.modInfo.fsize)
        fixedCells = self.fixedCells
        fixedCells.clear()
        #--File stream
        minfo_path = self.modInfo.getPath()
        #--Scan/Edit
        with ModReader(self.modInfo.ci_key, minfo_path.open(u'rb')) as ins:
            with minfo_path.temp.open(u'wb') as  out:
                def copy(bsize):
                    buff = ins.read(bsize)
                    out.write(buff)
                while not ins.atEnd():
                    progress(ins.tell())
                    header = ins.unpackRecHeader()
                    _rsig = header.recType
                    #(type,size,str0,fid,uint2) = ins.unpackRecHeader()
                    out.write(header.pack_head())
                    if _rsig == b'GRUP':
                        if header.groupType != 0: #--Ignore sub-groups
                            pass
                        elif header.label not in __wrld_types:
                            copy(header.blob_size())
                    #--Handle cells
                    elif _rsig == b'CELL':
                        nextRecord = ins.tell() + header.blob_size()
                        while ins.tell() < nextRecord:
                            subrec = SubrecordBlob(ins, _rsig)
                            if subrec.mel_sig == b'XCLL':
                                color, near, far, rotXY, rotZ, fade, clip = \
                                    __unpacker(subrec.mel_data)
                                if not (near or far or clip):
                                    near = 0.0001
                                    subrec.mel_data = __packer(color, near,
                                        far, rotXY, rotZ, fade, clip)
                                    fixedCells.add(header.fid)
                            subrec.packSub(out, subrec.mel_data)
                    #--Non-Cells
                    else:
                        copy(header.blob_size())
        #--Done
        if fixedCells:
            self.modInfo.makeBackup()
            minfo_path.untemp()
            self.modInfo.setmtime(crc_changed=True) # fog fixes
        else:
            minfo_path.temp.remove()
